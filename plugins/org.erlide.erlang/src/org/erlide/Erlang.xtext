grammar org.erlide.Erlang hidden(WS, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate erlang "http://www.erlide.org/Erlang"

Module:
	forms+=Form* 
;  

AbstractElement:
	  Module
	| Function
;

Form:
	  Attribute 
	| Function
	| ConditionalFormBlock
	| {MacroForm} call=MacroCall FULL_STOP 
;

ConditionalFormBlock:
	condition=IfdefAttribute 
		ifForms+=Form* 
	(=> hasElse?=ElseAttribute 
		elseForms+=Form*
	)? 
	end=EndifAttribute
;

// Attributes

ConditionalAttribute:
	  IfdefAttribute
	| ElseAttribute
	| EndifAttribute
;

Attribute:
	  ModuleAttribute
	| DefineAttribute
	| UndefAttribute 
	| AbstractIncludeAttribute
	| FileAttribute
	| RecordAttribute
	| AbstractTypeAttribute	
	| ExportAttribute
	| ImportAttribute
	| CompileAttribute
	| CustomAttribute
;

AbstractDefineAttribute:
	  DefineAttribute
	| UndefAttribute
;

DefineAttribute:
    '-' => tag='define' 		    
		'(' macroName=AtomVar // can't have feature 'name' because multiple defines with the same macro can exist 
		    ('(' (args+=PatternExpression (',' args+=PatternExpression)*)? ')' )? 
	    	(',' value=Guard?)? 
		')'
	FULL_STOP		 
;

UndefAttribute:
	'-' => tag='undef' '(' ref=[DefineAttribute|AtomVar] ')' FULL_STOP
;

IfdefAttribute:
	'-' => tag=('ifdef'|'ifndef') '(' ref=[DefineAttribute|AtomVar] ')' FULL_STOP
;

ElseAttribute:
	'-' => tag='else' FULL_STOP
;

EndifAttribute:
	'-' => tag='endif'	FULL_STOP
;

AbstractIncludeAttribute:
	  IncludeAttribute
	| IncludeLibAttribute
;
	
IncludeAttribute:
	'-' => tag=('include') '(' importURI=STRING ')' FULL_STOP
;

IncludeLibAttribute:
	'-' => tag=('include_lib') '(' importURI=STRING ')' FULL_STOP
;

FileAttribute:
	'-' => tag='file' '(' file=STRING ',' line=INTEGER ')' FULL_STOP
;

ModuleAttribute:
	'-' => tag='module' '(' moduleName=Name ')' FULL_STOP
;

RecordAttribute:
	'-' => tag='record' '(' name=NameVar ',' 
		('{' (fields+=RecordFieldDef (',' fields+=RecordFieldDef)*)? '}' | recordMacro=[DefineAttribute|Macro]) 
	')' 
	FULL_STOP  
;

ExportAttribute:
	'-' => tag='export' 
		'(' '[' (funs+=FunRef (',' funs+=FunRef)*)? ']' ')' 
	FULL_STOP
;

ImportAttribute:
	'-' => tag='import' 
		'(' module=Name ',' '[' (funs+=FunRef (',' funs+=FunRef)*)? ']' ')' 
	FULL_STOP
;

CompileAttribute:
	'-' => tag='compile' '(' options=Expression ')' 
	FULL_STOP
;

AbstractTypeAttribute:
  	  SpecAttribute
	| TypeAttribute
;

SpecAttribute:
	'-' => tag=('spec'|'callback') 
	(
  		      ref=SpecFun signatures+=TypeSig (';' signatures+=TypeSig)*
  		| '(' ref=SpecFun signatures+=TypeSig (';' signatures+=TypeSig)* ')'
	)
	FULL_STOP
;

TypeAttribute:
	'-' => tag=('type'|'opaque') 
	(
  	    	name=NameVar '(' (args+=PatternExpression (',' args+=PatternExpression)*)? ')' '::' type=TopType 
  	  | '(' name=NameVar '(' (args+=PatternExpression (',' args+=PatternExpression)*)? ')' '::' type=TopType ')'
	)
	FULL_STOP
;

CustomAttribute:
	'-' tag=ATOM '(' (value+=Expression (',' value+=Expression)*)? ')' FULL_STOP
;

// Functions

Function:
	name=AtomKw clauses+=FunctionClause ( ';' clauses+=FunctionClause )* FULL_STOP
;

// validate that all names for a function are identical
FunctionClause:
	  ref=AtomKw? '(' (params+=Expression (',' params+=Expression)*)? ')' 
	  ('when'? guard=Guard)? // no 'when' if guard is a macro
	  '->' body+=LExpression (',' body+=LExpression)*
;

Guard:
	guards+=Expressions (';' guards+=Expressions)*
;

Expressions:
	exprs+=LExpression (',' exprs+=LExpression)*
;

LExpression returns Expression:
	  => line?=LineExpr expr=Expression
	| Expression
;

LineExpr:
	'?' 'line'  
;

Expression returns Expression:
	  {CatchExpr} 'catch' expr=Expression 
	| Expr100 
;

Expr100 returns Expression: // right-associative
	Expr150 
	(   {MatchExpr.opLeft=current} op='=' opRight=Expr100
	  | {BinOp.opLeft=current} op='!' opRight=Expr100
	)?;

Expr150 returns Expression:
	Expr160 ({BinOp.opLeft=current} op='orelse' opRight=Expr160)*;

Expr160 returns Expression:
	Expr200 ({BinOp.opLeft=current} op='andalso' opRight2=Expr200)*;

Expr200 returns Expression: // non-associative
	Expr300 ({BinOp.opLeft=current} op=CompOp opRight=Expr300)?;

Expr300 returns Expression: 
	Expr400 ({BinOp.opLeft=current} op=ListOp opRight=Expr400)*;

Expr400 returns Expression:
	Expr500 ({AddOp.opLeft=current} op=AddOp opRight=Expr500)*;

Expr500 returns Expression:
	UnaryExpr ({MultOp.opLeft=current} op=MultOp opRight=UnaryExpr)*;

UnaryExpr returns Expression:
	  {UnaryExpr} op=PrefixOp operand=Expr700
	| Expr700
;

Expr700 returns Expression:
	Expr800 (	 
		  '(' {FunCall.target=current} (args+=Expression (',' args+=Expression)*)? ')' 
		  ('(' (args2+=Expression (',' args2+=Expression)*)? ')')?
		| ('#' {RecordExpr.ref=current} record=RecordExpr )+ 
	)? 
;

Expr800 returns Expression: // non-associative
	ExprMax ({RemoteTarget.module=current} ':' function=ExprMax)?
;

ExprMax returns Expression:
	  TermExpression
	| '(' Expression ')' 
	| {BlockExpr} 'begin' body+=LExpression (',' body+=LExpression)* 'end' 
	| IfExpr 
	| CaseExpr 
	| ReceiveExpr 
	| FunExpr 
	| TryExpr
	| CondExpr
	| QueryExpr
	| LetExpr
;

TermExpression returns Expression:	  
	  Tuple
	| => ListComprehension 
	| List 
	| => BinaryComprehension 
	| Binary 
	| '#' RecordExpr
	| LiteralExpression
;

MacroCall:
	  macroName=[DefineAttribute|Macro] ('(' (args+=Expression (',' args+=Expression)*)? ')')?  
;

RecordExpr:
	rec=[RecordAttribute|NameVar] (('.' field=[RecordFieldDef|Name]) | tuple=RecordTuple)
;

// NYI
QueryExpr:
	{QueryExpr} 'query'
;

// NYI
CondExpr:
	{CondExpr} 'cond'
;

// NYI
LetExpr:
	{LetExpr} 'let'
;

RecordTuple:
	{RecordTuple} '{' (fields+=RecordField (',' fields+=RecordField)*)? '}';

RecordFieldDef:
	name=NameVar ('=' value=Expression)? ('::' type=TopType)?
;

RecordField:
	ref=[RecordFieldDef|NameVar] ('=' value=Expression)? ('::' type=TopType)?
;

LiteralExpressionNoNumber returns Expression:
	  {Atom} value=[AbstractElement|AtomKw]
	| {Variable} value=VARIABLE 
	| {ErlChar} value=CHAR 
	| {MacroExpr} value=[DefineAttribute|Macro] 
	| {ErlString} value=ErlString
;

LiteralExpression returns Expression:
	  LiteralExpressionNoNumber
	| {ErlInteger} value=INTEGER 
	| {ErlFloat} value=FLOAT
;

PatternExpression returns Expression:
	TermExpression (
		({MatchExpr.opLeft=current} op='=' opRight=TermExpression)+
	  | ({FunCall.target=current} '(' (args+=Expression (',' args+=Expression)*)? ')') 
	)?
;

ErlString returns ecore::EString:
	STRING (STRING | Macro)* 
;

IfExpr:
	'if' clauses+=IfClause (';' clauses+=IfClause)* 'end'
;

IfClause:
	guard=Guard '->' body+=LExpression (',' body+=LExpression)*
;

CaseExpr:
	'case' expr=Expression 'of' clauses+=CrClause (';' clauses+=CrClause)* 'end'
;

CrClause:
	expr=Expression ('when' guard=Guard)? '->' body+=LExpression (',' body+=LExpression)*
;

ReceiveExpr:
	'receive' 
	( clauses+=CrClause (';' clauses+=CrClause)*
		('after' after_expr=Expression '->' after_body+=LExpression (',' after_body+=LExpression)*)? 
	  | 'after' after_expr=Expression '->' after_body+=LExpression (',' after_body+=LExpression)*
	) 
	'end'
;

FunExpr:
	'fun' (FunRef | InlineFun)
;

FunRef:
	//(module=[Module|NameVar] ':')? function=[Function|NameVar] '/' arity=IntMacro
	(module=NameVar ':')? function=NameVar '/' arity=IntMacro
;

InlineFun returns FunExpr:
	clauses+=FunctionClause (';' clauses+=FunctionClause)* 'end'
;

TryExpr:
	'try' body+=LExpression (',' body+=LExpression)* 
	('of' of_clauses+=CrClause (';' of_clauses+=CrClause)*)? 
	( 'catch' catch+=TryClause (';' catch+=TryClause)* ('after' after_body+=LExpression (',' after_body+=LExpression)*)? 
	  | 'after' after_body+=LExpression (',' after_body+=LExpression)*
    )   
	'end'
;

TryClause:
	(=> (hdr=NameVar ':')?) cond=PatternExpression 	
	('when' guard=Guard)? '->' body+=LExpression (',' body+=LExpression)*
;

List returns ErlList:
	'[' 
	(
	  {ErlList} 
	  | elements+=Expression (',' elements+=Expression)* ('|' tail=Expression)? 
	)
	']'
;

ListComprehension:
	'[' element=Expression '||' generators+=LCExpr (',' generators+=LCExpr)* ']'
;

Tuple returns ErlTuple:
	'{' 
	(   {ErlTuple} 
		| elements+=Expression (',' elements+=Expression)*
	)
	'}';

BinaryComprehension:
	'<<' expr=TermExpression '||' generators+=LCExpr (',' generators+=LCExpr)* '>>'
;

Binary returns ErlBinary:
	'<<' (     
		  {ErlBinary}
		| elements+=BinaryItem (',' elements+=BinaryItem)*
	) '>>'
;

BinaryItem:
	expr=UnaryExprMax (=> ':' size=ExprMax)? (=> '/' types+=BitType ('-' type+=BitType)*)? 
;

BitType:
	name=Name (':' size=INT)?
;

UnaryExprMax returns Expression:
	  {UnaryExpr} op=PrefixOp operand=ExprMax
	| ExprMax
;

LCExpr:
	o1=Expression (op=('<-'|'<=') o2=Expression)? 
;

// Operators

AddOp:
	'+' | '-' | 'bor' | 'bxor' | 'bsl' | 'bsr' | 'or' | 'xor';

MultOp:
	'*' | '/' | 'div' | 'rem' | 'band' | 'and';

PrefixOp:
	'+' | '-' | 'bnot' | 'not';

ListOp:
	'++' | '--';

CompOp:
	'==' | '/=' | '=<' | '<' | '>=' | '>' | '=:=' | '=/=';

// Literals

Name:
	AtomKw | Macro 
;

QName hidden():
	'.' Name 
;

NameVar:
	AtomVar | Macro 
;

AtomVar:
    AtomKw | VARIABLE
;

Macro:
    ('?'|'??') (ATOM | KW1 | VARIABLE)
;

AtomKw: 
	ATOM | KW
;

KW:
	KW1 | 'line'
;

KW1:
	'spec' | 'endif' | 'ifdef' | 'ifndef' | 'type' | 'opaque' | 'record' 
	| 'undef' | 'module' | 'include' | 'include_lib' | 'define'  
	| 'file' | 'callback' | 'else' | 'export' | 'import' | 'compile'
;

RealKw:
	  'after' | 'and' | 'andalso' | 'band' | 'begin' | 'bnot' | 'bor' | 'bsl' 
	| 'bsr' | 'bxor' | 'case' | 'catch' | 'cond' | 'div' | 'end' | 'fun' 
	| 'if' | 'let' | 'not' | 'of' | 'or' | 'orelse' | 'query' | 'receive' 
	| 'rem' | 'try' | 'when' | 'xor';

terminal ATOM:
	  ATOM_STARTER IN_WORD_CHAR* 
	| "'" ('\\' ESCAPE | !('\\' | "'"))* ("'" | EOF)
;

terminal STRING:
	'"' ('\\' ESCAPE | !('\\' | '"'))* ('"' | EOF);

terminal VARIABLE:
	('A'..'Z' | '_') IN_WORD_CHAR*;

terminal SL_COMMENT:
	'%' !('\n' | '\r')* ('\r'? '\n' | EOF);

terminal WS:
	(!('!'..'~'|'\u00a1'..'\u00ff'))+
;

terminal FULL_STOP:
	'.' (WS | SL_COMMENT | EOF)
;

IntMacro:
	INT | Macro | VARIABLE
;

INTEGER:
	  INT 
	| BASED_INT 
;

terminal BASED_INT:
	('1'..'3')? ('0'..'9') '#' ('0'..'9' | 'a'..'z' | 'A'..'Z')+
;

terminal INT:
	('0'..'9')+ 
;

FLOAT hidden():
	INT '.' ( EXT_INT | INT ) 
;

terminal EXT_INT:
	INT ('e' | 'E') ('+' | '-')? INT
;

terminal CHAR:
	'$' ('\\' ESCAPE | .);

terminal fragment IN_WORD_CHAR:
     'a'..'z' | 'A'..'Z' | '_' | '@' | '0'..'9' | 'ß'..'ö' | 'ø'..'ÿ' | 'À'..'Ö' | 'Ø'..'Þ'
;

terminal fragment ATOM_STARTER:
    'a'..'z' | 'ß'..'ö' | 'ø'..'ÿ'
;

terminal fragment ESCAPE:
	( 'b' | 'd' | 'e' | 'f' | 'n' | 'r' | 's' | 't' | 'v'
		| ('0'..'7' ('0'..'7' '0'..'7'?)?)
		| ('x'|'X') HEX_DIGIT HEX_DIGIT
		| ('x'|'X') '{' HEX_DIGIT+ '}'
		| '^' ('a'..'z' | 'A'..'Z' | ']')
		| .
	)
;

terminal fragment HEX_DIGIT:
	'0'..'9' | 'A'..'F' | 'a'..'f'
;

// Type language

SpecFun:
	(module=NameVar ':')? function=NameVar ('/' arity=IntMacro '::')?;

TypeSig:
	decl=FunType ('when' guards=TypeGuards)?;

FunType:
	'(' (args+=TopType (',' args+=TopType)*)? ')' '->' return=TopType;

TypeGuards:
	items+=TypeGuard (',' items+=TypeGuard)*;

TypeGuard:
	name=Name '(' types+=TopType (',' types+=TopType)* ')' | name=VARIABLE '::' type=TopType;

TopType:
	(var=VARIABLE '::')? type=Type100;

Type100:
	Type200 (=> ({TopType.leftOperand=current} op='|') rightOperand=Type200)*;

Type200:
	Type300 (=> ({TopType.leftOperand=current} op='..') rightOperand=Type300)*;

Type300:
	Type400 (=> ({TopType.leftOperand=current} op=AddOp) rightOperand=Type400)*;

Type400:
	Type500 (=> ({TopType.leftOperand=current} op=MultOp) rightOperand=Type500)*;

Type500:
	  {UnaryType} op=PrefixOp operand=Type
	| Type
;

Type:
	'(' TopType ')' 
	| {RemoteType} (m=[Module|Name] ':')? name=Name ('(' (args+=TopType (',' args+=TopType)*)? ')')? 
	| name=VARIABLE 
	| value=INTEGER 
	| '[' {ListType} (type=TopType	(',' '...')?)? ']' 
	| '{' {TupleType} (types+=TopType (',' types+=TopType)*)? '}' 
	| '#' {RecordType} rec=Name '{' (fields+=FieldType (',' fields+=FieldType)*)? '}' 
	| BinaryType
	| 'fun' {FunType} '(' type=FunType100? ')' 
;

FieldType:
	name=Name '::' type=TopType;

BinaryType:
	'<<' {BinaryType}
	(type+=BinBaseType (',' type+=BinUnitType)? | type+=BinUnitType)? 
	'>>'
;

BinBaseType:
	name=VARIABLE ':' type=Type;

BinUnitType:
	name=VARIABLE ':' m=VARIABLE '*' type=Type;

FunType100:
	{FunTypeList} '(' ('...' | (items+=TopType (',' items+=TopType)*))? ')' '->' return=TopType;


	