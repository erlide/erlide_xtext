/*
 * generated by Xtext
 */
package org.erlide.serializer;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.erlide.erlang.AddOp;
import org.erlide.erlang.Atom;
import org.erlide.erlang.AtomRef;
import org.erlide.erlang.BinBaseType;
import org.erlide.erlang.BinOp;
import org.erlide.erlang.BinUnitType;
import org.erlide.erlang.BinaryComprehension;
import org.erlide.erlang.BinaryItem;
import org.erlide.erlang.BinaryType;
import org.erlide.erlang.BitType;
import org.erlide.erlang.BlockExpr;
import org.erlide.erlang.CaseExpr;
import org.erlide.erlang.CatchExpr;
import org.erlide.erlang.CompileAttribute;
import org.erlide.erlang.CondExpr;
import org.erlide.erlang.ConditionalFormBlock;
import org.erlide.erlang.CrClause;
import org.erlide.erlang.CustomAttribute;
import org.erlide.erlang.DefineAttribute;
import org.erlide.erlang.ElseAttribute;
import org.erlide.erlang.EncodingAttribute;
import org.erlide.erlang.EndifAttribute;
import org.erlide.erlang.ErlBinary;
import org.erlide.erlang.ErlChar;
import org.erlide.erlang.ErlFloat;
import org.erlide.erlang.ErlInteger;
import org.erlide.erlang.ErlList;
import org.erlide.erlang.ErlTuple;
import org.erlide.erlang.ErlangPackage;
import org.erlide.erlang.ExportAttribute;
import org.erlide.erlang.Expression;
import org.erlide.erlang.Expressions;
import org.erlide.erlang.FieldType;
import org.erlide.erlang.FileAttribute;
import org.erlide.erlang.FunCall;
import org.erlide.erlang.FunExpr;
import org.erlide.erlang.FunRef;
import org.erlide.erlang.FunType;
import org.erlide.erlang.FunTypeList;
import org.erlide.erlang.Function;
import org.erlide.erlang.FunctionClause;
import org.erlide.erlang.Guard;
import org.erlide.erlang.IfClause;
import org.erlide.erlang.IfExpr;
import org.erlide.erlang.IfdefAttribute;
import org.erlide.erlang.ImportAttribute;
import org.erlide.erlang.IncludeAttribute;
import org.erlide.erlang.IncludeLibAttribute;
import org.erlide.erlang.LCExpr;
import org.erlide.erlang.LetExpr;
import org.erlide.erlang.ListComprehension;
import org.erlide.erlang.ListType;
import org.erlide.erlang.Macro;
import org.erlide.erlang.MacroCall;
import org.erlide.erlang.MacroForm;
import org.erlide.erlang.MatchExpr;
import org.erlide.erlang.Module;
import org.erlide.erlang.ModuleAttribute;
import org.erlide.erlang.MultOp;
import org.erlide.erlang.QueryExpr;
import org.erlide.erlang.ReceiveExpr;
import org.erlide.erlang.RecordAttribute;
import org.erlide.erlang.RecordExpr;
import org.erlide.erlang.RecordFieldDef;
import org.erlide.erlang.RecordFieldExpr;
import org.erlide.erlang.RecordTuple;
import org.erlide.erlang.RecordType;
import org.erlide.erlang.RemoteTarget;
import org.erlide.erlang.RemoteType;
import org.erlide.erlang.SpecAttribute;
import org.erlide.erlang.StringLiteralPart;
import org.erlide.erlang.TopType;
import org.erlide.erlang.TryClause;
import org.erlide.erlang.TryExpr;
import org.erlide.erlang.TupleType;
import org.erlide.erlang.Type;
import org.erlide.erlang.TypeAttribute;
import org.erlide.erlang.TypeGuard;
import org.erlide.erlang.TypeGuards;
import org.erlide.erlang.TypeSig;
import org.erlide.erlang.UnaryExpr;
import org.erlide.erlang.UnaryType;
import org.erlide.erlang.UndefAttribute;
import org.erlide.erlang.Variable;
import org.erlide.services.ErlangGrammarAccess;

import com.google.inject.Inject;

@SuppressWarnings("all")
public abstract class AbstractErlangSemanticSequencer extends
        AbstractDelegatingSemanticSequencer {

    @Inject
    private ErlangGrammarAccess grammarAccess;

    @Override
    public void createSequence(final EObject context,
            final EObject semanticObject) {
        if (semanticObject.eClass().getEPackage() == ErlangPackage.eINSTANCE) {
            switch (semanticObject.eClass().getClassifierID()) {
            case ErlangPackage.ADD_OP:
                sequence_Expr400(context, (AddOp) semanticObject);
                return;
            case ErlangPackage.ATOM:
                sequence_LiteralExpressionNoNumber(context,
                        (Atom) semanticObject);
                return;
            case ErlangPackage.ATOM_REF:
                if (context == grammarAccess.getFunctionRefRule()
                        || context == grammarAccess.getFunctionVarMacroRule()) {
                    sequence_FunctionRef(context, (AtomRef) semanticObject);
                    return;
                } else if (context == grammarAccess.getModuleRefRule()
                        || context == grammarAccess.getModuleVarMacroRule()) {
                    sequence_ModuleRef(context, (AtomRef) semanticObject);
                    return;
                } else if (context == grammarAccess.getRecordFieldRefRule()
                        || context == grammarAccess
                                .getRecordFieldVarMacroRule()) {
                    sequence_RecordFieldRef(context, (AtomRef) semanticObject);
                    return;
                } else if (context == grammarAccess.getRecordRefRule()
                        || context == grammarAccess.getRecordVarMacroRule()) {
                    sequence_RecordRef(context, (AtomRef) semanticObject);
                    return;
                } else if (context == grammarAccess.getTypeRefRule()
                        || context == grammarAccess.getTypeVarMacroRule()) {
                    sequence_TypeRef(context, (AtomRef) semanticObject);
                    return;
                } else {
                    break;
                }
            case ErlangPackage.BIN_BASE_TYPE:
                sequence_BinBaseType(context, (BinBaseType) semanticObject);
                return;
            case ErlangPackage.BIN_OP:
                sequence_Expr100_Expr150_Expr160_Expr200_Expr300(context,
                        (BinOp) semanticObject);
                return;
            case ErlangPackage.BIN_UNIT_TYPE:
                sequence_BinUnitType(context, (BinUnitType) semanticObject);
                return;
            case ErlangPackage.BINARY_COMPREHENSION:
                sequence_BinaryOrComprehension(context,
                        (BinaryComprehension) semanticObject);
                return;
            case ErlangPackage.BINARY_ITEM:
                sequence_BinaryItem(context, (BinaryItem) semanticObject);
                return;
            case ErlangPackage.BINARY_TYPE:
                sequence_BinaryType(context, (BinaryType) semanticObject);
                return;
            case ErlangPackage.BIT_TYPE:
                sequence_BitType(context, (BitType) semanticObject);
                return;
            case ErlangPackage.BLOCK_EXPR:
                sequence_ExprMax(context, (BlockExpr) semanticObject);
                return;
            case ErlangPackage.CASE_EXPR:
                sequence_CaseExpr(context, (CaseExpr) semanticObject);
                return;
            case ErlangPackage.CATCH_EXPR:
                sequence_Expression(context, (CatchExpr) semanticObject);
                return;
            case ErlangPackage.COMPILE_ATTRIBUTE:
                sequence_CompileAttribute(context,
                        (CompileAttribute) semanticObject);
                return;
            case ErlangPackage.COND_EXPR:
                sequence_CondExpr(context, (CondExpr) semanticObject);
                return;
            case ErlangPackage.CONDITIONAL_FORM_BLOCK:
                sequence_ConditionalFormBlock(context,
                        (ConditionalFormBlock) semanticObject);
                return;
            case ErlangPackage.CR_CLAUSE:
                sequence_CrClause(context, (CrClause) semanticObject);
                return;
            case ErlangPackage.CUSTOM_ATTRIBUTE:
                sequence_CustomAttribute(context,
                        (CustomAttribute) semanticObject);
                return;
            case ErlangPackage.DEFINE_ATTRIBUTE:
                sequence_DefineAttribute(context,
                        (DefineAttribute) semanticObject);
                return;
            case ErlangPackage.ELSE_ATTRIBUTE:
                sequence_ElseAttribute(context, (ElseAttribute) semanticObject);
                return;
            case ErlangPackage.ENCODING_ATTRIBUTE:
                sequence_EncodingAttribute(context,
                        (EncodingAttribute) semanticObject);
                return;
            case ErlangPackage.ENDIF_ATTRIBUTE:
                sequence_EndifAttribute(context,
                        (EndifAttribute) semanticObject);
                return;
            case ErlangPackage.ERL_BINARY:
                sequence_BinaryOrComprehension(context,
                        (ErlBinary) semanticObject);
                return;
            case ErlangPackage.ERL_CHAR:
                sequence_LiteralExpressionNoNumber(context,
                        (ErlChar) semanticObject);
                return;
            case ErlangPackage.ERL_FLOAT:
                sequence_LiteralExpression(context, (ErlFloat) semanticObject);
                return;
            case ErlangPackage.ERL_INTEGER:
                sequence_IntegerLiteral(context, (ErlInteger) semanticObject);
                return;
            case ErlangPackage.ERL_LIST:
                if (context == grammarAccess.getExpr100Rule()
                        || context == grammarAccess.getExpr100Access()
                                .getBinOpOpLeftAction_1_1_0()
                        || context == grammarAccess.getExpr100Access()
                                .getMatchExprOpLeftAction_1_0_0()
                        || context == grammarAccess.getExpr150Rule()
                        || context == grammarAccess.getExpr150Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr160Rule()
                        || context == grammarAccess.getExpr160Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr200Rule()
                        || context == grammarAccess.getExpr200Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr300Rule()
                        || context == grammarAccess.getExpr300Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr400Rule()
                        || context == grammarAccess.getExpr400Access()
                                .getAddOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr500Rule()
                        || context == grammarAccess.getExpr500Access()
                                .getMultOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr700Rule()
                        || context == grammarAccess.getExpr700Access()
                                .getFunCallTargetAction_1_0_1()
                        || context == grammarAccess.getExpr700Access()
                                .getRecordExprRefAction_1_1_1()
                        || context == grammarAccess.getExpr800Rule()
                        || context == grammarAccess.getExpr800Access()
                                .getRemoteTargetModuleAction_1_0()
                        || context == grammarAccess.getExprMaxRule()
                        || context == grammarAccess.getExpressionRule()
                        || context == grammarAccess.getLExpressionRule()
                        || context == grammarAccess
                                .getListOrComprehensionRule()
                        || context == grammarAccess.getPatternExpressionRule()
                        || context == grammarAccess
                                .getPatternExpressionAccess()
                                .getFunCallTargetAction_1_1_0()
                        || context == grammarAccess
                                .getPatternExpressionAccess()
                                .getMatchExprOpLeftAction_1_0_0()
                        || context == grammarAccess.getTermExpressionRule()
                        || context == grammarAccess.getUnaryExprRule()
                        || context == grammarAccess.getUnaryExprMaxRule()) {
                    sequence_ListOrComprehension(context,
                            (ErlList) semanticObject);
                    return;
                } else if (context == grammarAccess
                        .getListOrComprehensionAccess()
                        .getListComprehensionRootAction_1_1_2_1_0()) {
                    sequence_ListOrComprehension_ListComprehension_1_1_2_1_0(
                            context, (ErlList) semanticObject);
                    return;
                } else {
                    break;
                }
            case ErlangPackage.ERL_TUPLE:
                sequence_Tuple(context, (ErlTuple) semanticObject);
                return;
            case ErlangPackage.EXPORT_ATTRIBUTE:
                sequence_ExportAttribute(context,
                        (ExportAttribute) semanticObject);
                return;
            case ErlangPackage.EXPRESSION:
                sequence_StringLiteral(context, (Expression) semanticObject);
                return;
            case ErlangPackage.EXPRESSIONS:
                sequence_Expressions(context, (Expressions) semanticObject);
                return;
            case ErlangPackage.FIELD_TYPE:
                sequence_FieldType(context, (FieldType) semanticObject);
                return;
            case ErlangPackage.FILE_ATTRIBUTE:
                sequence_FileAttribute(context, (FileAttribute) semanticObject);
                return;
            case ErlangPackage.FUN_CALL:
                if (context == grammarAccess.getExpr100Rule()
                        || context == grammarAccess.getExpr100Access()
                                .getBinOpOpLeftAction_1_1_0()
                        || context == grammarAccess.getExpr100Access()
                                .getMatchExprOpLeftAction_1_0_0()
                        || context == grammarAccess.getExpr150Rule()
                        || context == grammarAccess.getExpr150Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr160Rule()
                        || context == grammarAccess.getExpr160Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr200Rule()
                        || context == grammarAccess.getExpr200Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr300Rule()
                        || context == grammarAccess.getExpr300Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr400Rule()
                        || context == grammarAccess.getExpr400Access()
                                .getAddOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr500Rule()
                        || context == grammarAccess.getExpr500Access()
                                .getMultOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr700Rule()
                        || context == grammarAccess.getExpr700Access()
                                .getFunCallTargetAction_1_0_1()
                        || context == grammarAccess.getExpr700Access()
                                .getRecordExprRefAction_1_1_1()
                        || context == grammarAccess.getExpr800Rule()
                        || context == grammarAccess.getExpr800Access()
                                .getRemoteTargetModuleAction_1_0()
                        || context == grammarAccess.getExprMaxRule()
                        || context == grammarAccess.getExpressionRule()
                        || context == grammarAccess.getLExpressionRule()
                        || context == grammarAccess.getUnaryExprRule()
                        || context == grammarAccess.getUnaryExprMaxRule()) {
                    sequence_Expr700(context, (FunCall) semanticObject);
                    return;
                } else if (context == grammarAccess.getPatternExpressionRule()) {
                    sequence_PatternExpression(context,
                            (FunCall) semanticObject);
                    return;
                } else {
                    break;
                }
            case ErlangPackage.FUN_EXPR:
                sequence_InlineFun(context, (FunExpr) semanticObject);
                return;
            case ErlangPackage.FUN_REF:
                if (context == grammarAccess.getExpr100Rule()
                        || context == grammarAccess.getExpr100Access()
                                .getBinOpOpLeftAction_1_1_0()
                        || context == grammarAccess.getExpr100Access()
                                .getMatchExprOpLeftAction_1_0_0()
                        || context == grammarAccess.getExpr150Rule()
                        || context == grammarAccess.getExpr150Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr160Rule()
                        || context == grammarAccess.getExpr160Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr200Rule()
                        || context == grammarAccess.getExpr200Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr300Rule()
                        || context == grammarAccess.getExpr300Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr400Rule()
                        || context == grammarAccess.getExpr400Access()
                                .getAddOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr500Rule()
                        || context == grammarAccess.getExpr500Access()
                                .getMultOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr700Rule()
                        || context == grammarAccess.getExpr700Access()
                                .getFunCallTargetAction_1_0_1()
                        || context == grammarAccess.getExpr700Access()
                                .getRecordExprRefAction_1_1_1()
                        || context == grammarAccess.getExpr800Rule()
                        || context == grammarAccess.getExpr800Access()
                                .getRemoteTargetModuleAction_1_0()
                        || context == grammarAccess.getExprMaxRule()
                        || context == grammarAccess.getExpressionRule()
                        || context == grammarAccess.getFunExprRule()
                        || context == grammarAccess.getFunRefRule()
                        || context == grammarAccess.getLExpressionRule()
                        || context == grammarAccess.getUnaryExprRule()
                        || context == grammarAccess.getUnaryExprMaxRule()) {
                    sequence_FunRef(context, (FunRef) semanticObject);
                    return;
                } else if (context == grammarAccess.getSpecFunRule()) {
                    sequence_SpecFun(context, (FunRef) semanticObject);
                    return;
                } else {
                    break;
                }
            case ErlangPackage.FUN_TYPE:
                if (context == grammarAccess.getFunTypeRule()) {
                    sequence_FunType(context, (FunType) semanticObject);
                    return;
                } else if (context == grammarAccess.getTypeRule()
                        || context == grammarAccess.getType100Rule()
                        || context == grammarAccess.getType100Access()
                                .getTopTypeLeftOperandAction_1_0_0_0()
                        || context == grammarAccess.getType200Rule()
                        || context == grammarAccess.getType200Access()
                                .getTopTypeLeftOperandAction_1_0_0_0()
                        || context == grammarAccess.getType300Rule()
                        || context == grammarAccess.getType300Access()
                                .getTopTypeLeftOperandAction_1_0_0_0()
                        || context == grammarAccess.getType400Rule()
                        || context == grammarAccess.getType400Access()
                                .getTopTypeLeftOperandAction_1_0_0_0()
                        || context == grammarAccess.getType500Rule()) {
                    sequence_Type(context, (FunType) semanticObject);
                    return;
                } else {
                    break;
                }
            case ErlangPackage.FUN_TYPE_LIST:
                sequence_FunType100(context, (FunTypeList) semanticObject);
                return;
            case ErlangPackage.FUNCTION:
                sequence_Function(context, (Function) semanticObject);
                return;
            case ErlangPackage.FUNCTION_CLAUSE:
                sequence_FunctionClause(context,
                        (FunctionClause) semanticObject);
                return;
            case ErlangPackage.GUARD:
                sequence_Guard(context, (Guard) semanticObject);
                return;
            case ErlangPackage.IF_CLAUSE:
                sequence_IfClause(context, (IfClause) semanticObject);
                return;
            case ErlangPackage.IF_EXPR:
                sequence_IfExpr(context, (IfExpr) semanticObject);
                return;
            case ErlangPackage.IFDEF_ATTRIBUTE:
                sequence_IfdefAttribute(context,
                        (IfdefAttribute) semanticObject);
                return;
            case ErlangPackage.IMPORT_ATTRIBUTE:
                sequence_ImportAttribute(context,
                        (ImportAttribute) semanticObject);
                return;
            case ErlangPackage.INCLUDE_ATTRIBUTE:
                sequence_IncludeAttribute(context,
                        (IncludeAttribute) semanticObject);
                return;
            case ErlangPackage.INCLUDE_LIB_ATTRIBUTE:
                sequence_IncludeLibAttribute(context,
                        (IncludeLibAttribute) semanticObject);
                return;
            case ErlangPackage.LC_EXPR:
                sequence_LCExpr(context, (LCExpr) semanticObject);
                return;
            case ErlangPackage.LET_EXPR:
                sequence_LetExpr(context, (LetExpr) semanticObject);
                return;
            case ErlangPackage.LIST_COMPREHENSION:
                sequence_ListOrComprehension(context,
                        (ListComprehension) semanticObject);
                return;
            case ErlangPackage.LIST_TYPE:
                sequence_Type(context, (ListType) semanticObject);
                return;
            case ErlangPackage.MACRO:
                if (context == grammarAccess.getExpr100Rule()
                        || context == grammarAccess.getExpr100Access()
                                .getBinOpOpLeftAction_1_1_0()
                        || context == grammarAccess.getExpr100Access()
                                .getMatchExprOpLeftAction_1_0_0()
                        || context == grammarAccess.getExpr150Rule()
                        || context == grammarAccess.getExpr150Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr160Rule()
                        || context == grammarAccess.getExpr160Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr200Rule()
                        || context == grammarAccess.getExpr200Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr300Rule()
                        || context == grammarAccess.getExpr300Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr400Rule()
                        || context == grammarAccess.getExpr400Access()
                                .getAddOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr500Rule()
                        || context == grammarAccess.getExpr500Access()
                                .getMultOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr700Rule()
                        || context == grammarAccess.getExpr700Access()
                                .getFunCallTargetAction_1_0_1()
                        || context == grammarAccess.getExpr700Access()
                                .getRecordExprRefAction_1_1_1()
                        || context == grammarAccess.getExpr800Rule()
                        || context == grammarAccess.getExpr800Access()
                                .getRemoteTargetModuleAction_1_0()
                        || context == grammarAccess.getExprMaxRule()
                        || context == grammarAccess.getExpressionRule()
                        || context == grammarAccess.getFunctionVarMacroRule()
                        || context == grammarAccess.getIntVarMacroRule()
                        || context == grammarAccess.getLExpressionRule()
                        || context == grammarAccess.getLiteralExpressionRule()
                        || context == grammarAccess
                                .getLiteralExpressionNoNumberRule()
                        || context == grammarAccess.getMacroLiteralRule()
                        || context == grammarAccess.getModuleVarMacroRule()
                        || context == grammarAccess.getPatternExpressionRule()
                        || context == grammarAccess
                                .getPatternExpressionAccess()
                                .getFunCallTargetAction_1_1_0()
                        || context == grammarAccess
                                .getPatternExpressionAccess()
                                .getMatchExprOpLeftAction_1_0_0()
                        || context == grammarAccess
                                .getRecordFieldVarMacroRule()
                        || context == grammarAccess.getRecordVarMacroRule()
                        || context == grammarAccess.getTermExpressionRule()
                        || context == grammarAccess.getTypeVarMacroRule()
                        || context == grammarAccess.getUnaryExprRule()
                        || context == grammarAccess.getUnaryExprMaxRule()) {
                    sequence_MacroLiteral(context, (Macro) semanticObject);
                    return;
                } else if (context == grammarAccess.getMacroRefRule()) {
                    sequence_MacroRef(context, (Macro) semanticObject);
                    return;
                } else {
                    break;
                }
            case ErlangPackage.MACRO_CALL:
                sequence_MacroCall(context, (MacroCall) semanticObject);
                return;
            case ErlangPackage.MACRO_FORM:
                sequence_Form(context, (MacroForm) semanticObject);
                return;
            case ErlangPackage.MATCH_EXPR:
                if (context == grammarAccess.getExpr100Rule()
                        || context == grammarAccess.getExpr100Access()
                                .getBinOpOpLeftAction_1_1_0()
                        || context == grammarAccess.getExpr100Access()
                                .getMatchExprOpLeftAction_1_0_0()
                        || context == grammarAccess.getExpr150Rule()
                        || context == grammarAccess.getExpr150Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr160Rule()
                        || context == grammarAccess.getExpr160Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr200Rule()
                        || context == grammarAccess.getExpr200Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr300Rule()
                        || context == grammarAccess.getExpr300Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr400Rule()
                        || context == grammarAccess.getExpr400Access()
                                .getAddOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr500Rule()
                        || context == grammarAccess.getExpr500Access()
                                .getMultOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr700Rule()
                        || context == grammarAccess.getExpr700Access()
                                .getFunCallTargetAction_1_0_1()
                        || context == grammarAccess.getExpr700Access()
                                .getRecordExprRefAction_1_1_1()
                        || context == grammarAccess.getExpr800Rule()
                        || context == grammarAccess.getExpr800Access()
                                .getRemoteTargetModuleAction_1_0()
                        || context == grammarAccess.getExprMaxRule()
                        || context == grammarAccess.getExpressionRule()
                        || context == grammarAccess.getLExpressionRule()
                        || context == grammarAccess.getUnaryExprRule()
                        || context == grammarAccess.getUnaryExprMaxRule()) {
                    sequence_Expr100(context, (MatchExpr) semanticObject);
                    return;
                } else if (context == grammarAccess.getPatternExpressionRule()
                        || context == grammarAccess
                                .getPatternExpressionAccess()
                                .getMatchExprOpLeftAction_1_0_0()) {
                    sequence_PatternExpression(context,
                            (MatchExpr) semanticObject);
                    return;
                } else {
                    break;
                }
            case ErlangPackage.MODULE:
                sequence_Module(context, (Module) semanticObject);
                return;
            case ErlangPackage.MODULE_ATTRIBUTE:
                sequence_ModuleAttribute(context,
                        (ModuleAttribute) semanticObject);
                return;
            case ErlangPackage.MULT_OP:
                sequence_Expr500(context, (MultOp) semanticObject);
                return;
            case ErlangPackage.QUERY_EXPR:
                sequence_QueryExpr(context, (QueryExpr) semanticObject);
                return;
            case ErlangPackage.RECEIVE_EXPR:
                sequence_ReceiveExpr(context, (ReceiveExpr) semanticObject);
                return;
            case ErlangPackage.RECORD_ATTRIBUTE:
                sequence_RecordAttribute(context,
                        (RecordAttribute) semanticObject);
                return;
            case ErlangPackage.RECORD_EXPR:
                if (context == grammarAccess.getExpr100Rule()
                        || context == grammarAccess.getExpr100Access()
                                .getBinOpOpLeftAction_1_1_0()
                        || context == grammarAccess.getExpr100Access()
                                .getMatchExprOpLeftAction_1_0_0()
                        || context == grammarAccess.getExpr150Rule()
                        || context == grammarAccess.getExpr150Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr160Rule()
                        || context == grammarAccess.getExpr160Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr200Rule()
                        || context == grammarAccess.getExpr200Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr300Rule()
                        || context == grammarAccess.getExpr300Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr400Rule()
                        || context == grammarAccess.getExpr400Access()
                                .getAddOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr500Rule()
                        || context == grammarAccess.getExpr500Access()
                                .getMultOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr700Rule()
                        || context == grammarAccess.getExpr700Access()
                                .getFunCallTargetAction_1_0_1()
                        || context == grammarAccess.getExpr700Access()
                                .getRecordExprRefAction_1_1_1()
                        || context == grammarAccess.getExpr800Rule()
                        || context == grammarAccess.getExpr800Access()
                                .getRemoteTargetModuleAction_1_0()
                        || context == grammarAccess.getExprMaxRule()
                        || context == grammarAccess.getExpressionRule()
                        || context == grammarAccess.getLExpressionRule()
                        || context == grammarAccess.getUnaryExprRule()
                        || context == grammarAccess.getUnaryExprMaxRule()) {
                    sequence_Expr700_RecordExpr(context,
                            (RecordExpr) semanticObject);
                    return;
                } else if (context == grammarAccess.getPatternExpressionRule()
                        || context == grammarAccess
                                .getPatternExpressionAccess()
                                .getFunCallTargetAction_1_1_0()
                        || context == grammarAccess
                                .getPatternExpressionAccess()
                                .getMatchExprOpLeftAction_1_0_0()
                        || context == grammarAccess.getRecordExprRule()
                        || context == grammarAccess.getTermExpressionRule()) {
                    sequence_RecordExpr(context, (RecordExpr) semanticObject);
                    return;
                } else {
                    break;
                }
            case ErlangPackage.RECORD_FIELD_DEF:
                sequence_RecordFieldDef(context,
                        (RecordFieldDef) semanticObject);
                return;
            case ErlangPackage.RECORD_FIELD_EXPR:
                sequence_RecordFieldExpr(context,
                        (RecordFieldExpr) semanticObject);
                return;
            case ErlangPackage.RECORD_TUPLE:
                sequence_RecordTuple(context, (RecordTuple) semanticObject);
                return;
            case ErlangPackage.RECORD_TYPE:
                sequence_Type(context, (RecordType) semanticObject);
                return;
            case ErlangPackage.REMOTE_TARGET:
                sequence_Expr800(context, (RemoteTarget) semanticObject);
                return;
            case ErlangPackage.REMOTE_TYPE:
                sequence_Type(context, (RemoteType) semanticObject);
                return;
            case ErlangPackage.SPEC_ATTRIBUTE:
                sequence_SpecAttribute(context, (SpecAttribute) semanticObject);
                return;
            case ErlangPackage.STRING_LITERAL_PART:
                sequence_StringLiteralLiteral(context,
                        (StringLiteralPart) semanticObject);
                return;
            case ErlangPackage.TOP_TYPE:
                if (context == grammarAccess.getTopTypeRule()
                        || context == grammarAccess.getTypeRule()
                        || context == grammarAccess.getType500Rule()) {
                    sequence_TopType(context, (TopType) semanticObject);
                    return;
                } else if (context == grammarAccess.getType100Rule()
                        || context == grammarAccess.getType100Access()
                                .getTopTypeLeftOperandAction_1_0_0_0()) {
                    sequence_TopType_Type100_Type200_Type300_Type400(context,
                            (TopType) semanticObject);
                    return;
                } else if (context == grammarAccess.getType200Rule()
                        || context == grammarAccess.getType200Access()
                                .getTopTypeLeftOperandAction_1_0_0_0()) {
                    sequence_TopType_Type200_Type300_Type400(context,
                            (TopType) semanticObject);
                    return;
                } else if (context == grammarAccess.getType300Rule()
                        || context == grammarAccess.getType300Access()
                                .getTopTypeLeftOperandAction_1_0_0_0()) {
                    sequence_TopType_Type300_Type400(context,
                            (TopType) semanticObject);
                    return;
                } else if (context == grammarAccess.getType400Rule()
                        || context == grammarAccess.getType400Access()
                                .getTopTypeLeftOperandAction_1_0_0_0()) {
                    sequence_TopType_Type400(context, (TopType) semanticObject);
                    return;
                } else {
                    break;
                }
            case ErlangPackage.TRY_CLAUSE:
                sequence_TryClause(context, (TryClause) semanticObject);
                return;
            case ErlangPackage.TRY_EXPR:
                sequence_TryExpr(context, (TryExpr) semanticObject);
                return;
            case ErlangPackage.TUPLE_TYPE:
                sequence_Type(context, (TupleType) semanticObject);
                return;
            case ErlangPackage.TYPE:
                sequence_Type(context, (Type) semanticObject);
                return;
            case ErlangPackage.TYPE_ATTRIBUTE:
                sequence_TypeAttribute(context, (TypeAttribute) semanticObject);
                return;
            case ErlangPackage.TYPE_GUARD:
                sequence_TypeGuard(context, (TypeGuard) semanticObject);
                return;
            case ErlangPackage.TYPE_GUARDS:
                sequence_TypeGuards(context, (TypeGuards) semanticObject);
                return;
            case ErlangPackage.TYPE_SIG:
                sequence_TypeSig(context, (TypeSig) semanticObject);
                return;
            case ErlangPackage.UNARY_EXPR:
                if (context == grammarAccess.getExpr100Rule()
                        || context == grammarAccess.getExpr100Access()
                                .getBinOpOpLeftAction_1_1_0()
                        || context == grammarAccess.getExpr100Access()
                                .getMatchExprOpLeftAction_1_0_0()
                        || context == grammarAccess.getExpr150Rule()
                        || context == grammarAccess.getExpr150Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr160Rule()
                        || context == grammarAccess.getExpr160Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr200Rule()
                        || context == grammarAccess.getExpr200Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr300Rule()
                        || context == grammarAccess.getExpr300Access()
                                .getBinOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr400Rule()
                        || context == grammarAccess.getExpr400Access()
                                .getAddOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr500Rule()
                        || context == grammarAccess.getExpr500Access()
                                .getMultOpOpLeftAction_1_0()
                        || context == grammarAccess.getExpr700Rule()
                        || context == grammarAccess.getExpr700Access()
                                .getFunCallTargetAction_1_0_1()
                        || context == grammarAccess.getExpr700Access()
                                .getRecordExprRefAction_1_1_1()
                        || context == grammarAccess.getExpr800Rule()
                        || context == grammarAccess.getExpr800Access()
                                .getRemoteTargetModuleAction_1_0()
                        || context == grammarAccess.getExprMaxRule()
                        || context == grammarAccess.getExpressionRule()
                        || context == grammarAccess.getLExpressionRule()
                        || context == grammarAccess.getUnaryExprRule()) {
                    sequence_UnaryExpr(context, (UnaryExpr) semanticObject);
                    return;
                } else if (context == grammarAccess.getUnaryExprMaxRule()) {
                    sequence_UnaryExpr_UnaryExprMax(context,
                            (UnaryExpr) semanticObject);
                    return;
                } else {
                    break;
                }
            case ErlangPackage.UNARY_TYPE:
                sequence_Type500(context, (UnaryType) semanticObject);
                return;
            case ErlangPackage.UNDEF_ATTRIBUTE:
                sequence_UndefAttribute(context,
                        (UndefAttribute) semanticObject);
                return;
            case ErlangPackage.VARIABLE:
                sequence_VariableLiteral(context, (Variable) semanticObject);
                return;
            }
        }
        if (errorAcceptor != null) {
            errorAcceptor.accept(diagnosticProvider
                    .createInvalidContextOrTypeDiagnostic(semanticObject,
                            context));
        }
    }

    /**
     * Constraint: (typeName=VariableLiteral type=Type)
     */
    protected void sequence_BinBaseType(final EObject context,
            final BinBaseType semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.BIN_BASE_TYPE__TYPE_NAME) == ValueTransient.YES) {
                errorAcceptor
                        .accept(diagnosticProvider
                                .createFeatureValueMissing(
                                        semanticObject,
                                        ErlangPackage.Literals.BIN_BASE_TYPE__TYPE_NAME));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.BIN_BASE_TYPE__TYPE) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.BIN_BASE_TYPE__TYPE));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getBinBaseTypeAccess()
                .getTypeNameVariableLiteralParserRuleCall_0_0(), semanticObject
                .getTypeName());
        feeder.accept(grammarAccess.getBinBaseTypeAccess()
                .getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
        feeder.finish();
    }

    /**
     * Constraint: (typeName=VariableLiteral m=VARIABLE type=Type)
     */
    protected void sequence_BinUnitType(final EObject context,
            final BinUnitType semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.BIN_UNIT_TYPE__TYPE_NAME) == ValueTransient.YES) {
                errorAcceptor
                        .accept(diagnosticProvider
                                .createFeatureValueMissing(
                                        semanticObject,
                                        ErlangPackage.Literals.BIN_UNIT_TYPE__TYPE_NAME));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.BIN_UNIT_TYPE__M) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.BIN_UNIT_TYPE__M));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.BIN_UNIT_TYPE__TYPE) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.BIN_UNIT_TYPE__TYPE));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getBinUnitTypeAccess()
                .getTypeNameVariableLiteralParserRuleCall_0_0(), semanticObject
                .getTypeName());
        feeder.accept(grammarAccess.getBinUnitTypeAccess()
                .getMVARIABLETerminalRuleCall_2_0(), semanticObject.getM());
        feeder.accept(grammarAccess.getBinUnitTypeAccess()
                .getTypeTypeParserRuleCall_4_0(), semanticObject.getType());
        feeder.finish();
    }

    /**
     * Constraint: (expr=UnaryExprMax size=ExprMax? (types+=BitType
     * type+=BitType*)?)
     */
    protected void sequence_BinaryItem(final EObject context,
            final BinaryItem semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (root=BinaryOrComprehension_BinaryComprehension_1_1_2_0
     * generators+=LCExpr generators+=LCExpr*)
     */
    protected void sequence_BinaryOrComprehension(final EObject context,
            final BinaryComprehension semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (elements+=BinaryItem elements+=BinaryItem*)
     */
    protected void sequence_BinaryOrComprehension(final EObject context,
            final ErlBinary semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (((type+=BinBaseType type+=BinUnitType?) |
     * type+=BinUnitType)?)
     */
    protected void sequence_BinaryType(final EObject context,
            final BinaryType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (typeName=[AtomRefTarget|NAMEMACRO] size=IntVarMacro?)
     */
    protected void sequence_BitType(final EObject context,
            final BitType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (expr=Expression clauses+=CrClause clauses+=CrClause*)
     */
    protected void sequence_CaseExpr(final EObject context,
            final CaseExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (tag='compile' options=Expression)
     */
    protected void sequence_CompileAttribute(final EObject context,
            final CompileAttribute semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.ATTRIBUTE__TAG) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.ATTRIBUTE__TAG));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.COMPILE_ATTRIBUTE__OPTIONS) == ValueTransient.YES) {
                errorAcceptor
                        .accept(diagnosticProvider
                                .createFeatureValueMissing(
                                        semanticObject,
                                        ErlangPackage.Literals.COMPILE_ATTRIBUTE__OPTIONS));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getCompileAttributeAccess()
                .getTagCompileKeyword_0_0(), semanticObject.getTag());
        feeder.accept(grammarAccess.getCompileAttributeAccess()
                .getOptionsExpressionParserRuleCall_2_0(), semanticObject
                .getOptions());
        feeder.finish();
    }

    /**
     * Constraint: {CondExpr}
     */
    protected void sequence_CondExpr(final EObject context,
            final CondExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (condition=IfdefAttribute ifForms+=Form*
     * (hasElse?=ElseAttribute elseForms+=Form*)? end=EndifAttribute)
     */
    protected void sequence_ConditionalFormBlock(final EObject context,
            final ConditionalFormBlock semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (expr=Expression guard=Guard? body=Expressions)
     */
    protected void sequence_CrClause(final EObject context,
            final CrClause semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (tag=ATOM (value+=Expression value+=Expression*)?)
     */
    protected void sequence_CustomAttribute(final EObject context,
            final CustomAttribute semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (tag='define' macroName=NAMEVAR (args+=PatternExpression
     * args+=PatternExpression*)? value=Guard?)
     */
    protected void sequence_DefineAttribute(final EObject context,
            final DefineAttribute semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: tag='else'
     */
    protected void sequence_ElseAttribute(final EObject context,
            final ElseAttribute semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.CONDITIONAL_ATTRIBUTE__TAG) == ValueTransient.YES) {
                errorAcceptor
                        .accept(diagnosticProvider
                                .createFeatureValueMissing(
                                        semanticObject,
                                        ErlangPackage.Literals.CONDITIONAL_ATTRIBUTE__TAG));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getElseAttributeAccess()
                .getTagElseKeyword_1_0(), semanticObject.getTag());
        feeder.finish();
    }

    /**
     * Constraint: (tag='encoding' (charset=NAME | charset=NAME))
     */
    protected void sequence_EncodingAttribute(final EObject context,
            final EncodingAttribute semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: tag='endif'
     */
    protected void sequence_EndifAttribute(final EObject context,
            final EndifAttribute semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.CONDITIONAL_ATTRIBUTE__TAG) == ValueTransient.YES) {
                errorAcceptor
                        .accept(diagnosticProvider
                                .createFeatureValueMissing(
                                        semanticObject,
                                        ErlangPackage.Literals.CONDITIONAL_ATTRIBUTE__TAG));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getEndifAttributeAccess()
                .getTagEndifKeyword_1_0(), semanticObject.getTag());
        feeder.finish();
    }

    /**
     * Constraint: (tag='export' (funs+=FunRef funs+=FunRef*)?)
     */
    protected void sequence_ExportAttribute(final EObject context,
            final ExportAttribute semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ( (opLeft=Expr200_BinOp_1_0 op=COMPOP opRight=Expr300) |
     * (opLeft=Expr300_BinOp_1_0 op=LISTOP opRight=Expr400) |
     * (opLeft=Expr160_BinOp_1_0 op='andalso' opRight2=Expr200) |
     * (opLeft=Expr150_BinOp_1_0 op='orelse' opRight=Expr160) |
     * (opLeft=Expr100_BinOp_1_1_0 op=SENDOP opRight=Expr100) )
     */
    protected void sequence_Expr100_Expr150_Expr160_Expr200_Expr300(
            final EObject context, final BinOp semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (opLeft=Expr100_MatchExpr_1_0_0 op='=' opRight=Expr100)
     */
    protected void sequence_Expr100(final EObject context,
            final MatchExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (opLeft=Expr400_AddOp_1_0 op=ADDOP opRight=Expr500)
     */
    protected void sequence_Expr400(final EObject context,
            final AddOp semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (opLeft=Expr500_MultOp_1_0 op=MULTOP opRight=UnaryExpr)
     */
    protected void sequence_Expr500(final EObject context,
            final MultOp semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ( (target=Expr700_FunCall_1_0_1 args=Expressions?
     * args2=Expressions?) | (target=Expr700_FunCall_1_0_1 args2=Expressions?) |
     * target=Expr700_FunCall_1_0_1 )
     */
    protected void sequence_Expr700(final EObject context,
            final FunCall semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((ref=Expr700_RecordExpr_1_1_1 record=RecordExpr) |
     * (rec=RecordVarMacro (field=RecordFieldVarMacro | tuple=RecordTuple)))
     */
    protected void sequence_Expr700_RecordExpr(final EObject context,
            final RecordExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (module=Expr800_RemoteTarget_1_0 function=ExprMax)
     */
    protected void sequence_Expr800(final EObject context,
            final RemoteTarget semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: body=Expressions
     */
    protected void sequence_ExprMax(final EObject context,
            final BlockExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: expr=Expression
     */
    protected void sequence_Expression(final EObject context,
            final CatchExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (exprs+=LExpression exprs+=LExpression*)
     */
    protected void sequence_Expressions(final EObject context,
            final Expressions semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (typeName=[TypeAttribute|ATOM] type=TopType)
     */
    protected void sequence_FieldType(final EObject context,
            final FieldType semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.FIELD_TYPE__TYPE_NAME) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.FIELD_TYPE__TYPE_NAME));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.FIELD_TYPE__TYPE) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.FIELD_TYPE__TYPE));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getFieldTypeAccess()
                .getTypeNameTypeAttributeATOMTerminalRuleCall_0_0_1(),
                semanticObject.getTypeName());
        feeder.accept(grammarAccess.getFieldTypeAccess()
                .getTypeTopTypeParserRuleCall_2_0(), semanticObject.getType());
        feeder.finish();
    }

    /**
     * Constraint: (tag='file' file=STRING line=INTEGER)
     */
    protected void sequence_FileAttribute(final EObject context,
            final FileAttribute semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.ATTRIBUTE__TAG) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.ATTRIBUTE__TAG));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.FILE_ATTRIBUTE__FILE) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.FILE_ATTRIBUTE__FILE));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.FILE_ATTRIBUTE__LINE) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.FILE_ATTRIBUTE__LINE));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getFileAttributeAccess()
                .getTagFileKeyword_0_0(), semanticObject.getTag());
        feeder.accept(grammarAccess.getFileAttributeAccess()
                .getFileSTRINGTerminalRuleCall_2_0(), semanticObject.getFile());
        feeder.accept(grammarAccess.getFileAttributeAccess()
                .getLineINTEGERParserRuleCall_4_0(), semanticObject.getLine());
        feeder.finish();
    }

    /**
     * Constraint: call=MacroCall
     */
    protected void sequence_Form(final EObject context,
            final MacroForm semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.MACRO_FORM__CALL) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.MACRO_FORM__CALL));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getFormAccess()
                .getCallMacroCallParserRuleCall_3_1_0(), semanticObject
                .getCall());
        feeder.finish();
    }

    /**
     * Constraint: (module=ModuleVarMacro? function=FunctionVarMacro
     * arity=IntVarMacro)
     */
    protected void sequence_FunRef(final EObject context,
            final FunRef semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((items+=TopType items+=TopType*)? return=TopType)
     */
    protected void sequence_FunType100(final EObject context,
            final FunTypeList semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((args+=TopType args+=TopType*)? return=TopType)
     */
    protected void sequence_FunType(final EObject context,
            final FunType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (ref=[Function|NAME]? params=Expressions? guard=Guard?
     * body=Expressions)
     */
    protected void sequence_FunctionClause(final EObject context,
            final FunctionClause semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=[Function|NAME]
     */
    protected void sequence_FunctionRef(final EObject context,
            final AtomRef semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (name=NAME clauses+=FunctionClause clauses+=FunctionClause*)
     */
    protected void sequence_Function(final EObject context,
            final Function semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (guards+=Expressions guards+=Expressions*)
     */
    protected void sequence_Guard(final EObject context,
            final Guard semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (guard=Guard body=Expressions)
     */
    protected void sequence_IfClause(final EObject context,
            final IfClause semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.IF_CLAUSE__GUARD) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.IF_CLAUSE__GUARD));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.IF_CLAUSE__BODY) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.IF_CLAUSE__BODY));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getIfClauseAccess()
                .getGuardGuardParserRuleCall_0_0(), semanticObject.getGuard());
        feeder.accept(grammarAccess.getIfClauseAccess()
                .getBodyExpressionsParserRuleCall_2_0(), semanticObject
                .getBody());
        feeder.finish();
    }

    /**
     * Constraint: (clauses+=IfClause clauses+=IfClause*)
     */
    protected void sequence_IfExpr(final EObject context,
            final IfExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((tag='ifdef' | tag='ifndef') ref=MacroRef)
     */
    protected void sequence_IfdefAttribute(final EObject context,
            final IfdefAttribute semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (tag='import' module=ModuleVarMacro (funs+=FunRef
     * funs+=FunRef*)?)
     */
    protected void sequence_ImportAttribute(final EObject context,
            final ImportAttribute semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (tag='include' importURI=STRING)
     */
    protected void sequence_IncludeAttribute(final EObject context,
            final IncludeAttribute semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.ATTRIBUTE__TAG) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.ATTRIBUTE__TAG));
            }
            if (transientValues
                    .isValueTransient(
                            semanticObject,
                            ErlangPackage.Literals.ABSTRACT_INCLUDE_ATTRIBUTE__IMPORT_URI) == ValueTransient.YES) {
                errorAcceptor
                        .accept(diagnosticProvider
                                .createFeatureValueMissing(
                                        semanticObject,
                                        ErlangPackage.Literals.ABSTRACT_INCLUDE_ATTRIBUTE__IMPORT_URI));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getIncludeAttributeAccess()
                .getTagIncludeKeyword_0_0(), semanticObject.getTag());
        feeder.accept(grammarAccess.getIncludeAttributeAccess()
                .getImportURISTRINGTerminalRuleCall_2_0(), semanticObject
                .getImportURI());
        feeder.finish();
    }

    /**
     * Constraint: (tag='include_lib' importURI=STRING)
     */
    protected void sequence_IncludeLibAttribute(final EObject context,
            final IncludeLibAttribute semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.ATTRIBUTE__TAG) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.ATTRIBUTE__TAG));
            }
            if (transientValues
                    .isValueTransient(
                            semanticObject,
                            ErlangPackage.Literals.ABSTRACT_INCLUDE_ATTRIBUTE__IMPORT_URI) == ValueTransient.YES) {
                errorAcceptor
                        .accept(diagnosticProvider
                                .createFeatureValueMissing(
                                        semanticObject,
                                        ErlangPackage.Literals.ABSTRACT_INCLUDE_ATTRIBUTE__IMPORT_URI));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getIncludeLibAttributeAccess()
                .getTagInclude_libKeyword_0_0(), semanticObject.getTag());
        feeder.accept(grammarAccess.getIncludeLibAttributeAccess()
                .getImportURISTRINGTerminalRuleCall_2_0(), semanticObject
                .getImportURI());
        feeder.finish();
    }

    /**
     * Constraint: (clauses+=FunctionClause clauses+=FunctionClause*)
     */
    protected void sequence_InlineFun(final EObject context,
            final FunExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=INTEGER
     */
    protected void sequence_IntegerLiteral(final EObject context,
            final ErlInteger semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (o1=Expression ((op='<-' | op='<=') o2=Expression)?)
     */
    protected void sequence_LCExpr(final EObject context,
            final LCExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: {LetExpr}
     */
    protected void sequence_LetExpr(final EObject context,
            final LetExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (elements+=Expression elements+=Expression* tail=Expression)
     */
    protected void sequence_ListOrComprehension(final EObject context,
            final ErlList semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (root=ListOrComprehension_ListComprehension_1_1_2_1_0
     * generators+=LCExpr generators+=LCExpr*)
     */
    protected void sequence_ListOrComprehension(final EObject context,
            final ListComprehension semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (elements+=Expression elements+=Expression*)
     */
    protected void sequence_ListOrComprehension_ListComprehension_1_1_2_1_0(
            final EObject context, final ErlList semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=NAME
     */
    protected void sequence_LiteralExpressionNoNumber(final EObject context,
            final Atom semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=CHAR
     */
    protected void sequence_LiteralExpressionNoNumber(final EObject context,
            final ErlChar semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=FLOAT
     */
    protected void sequence_LiteralExpression(final EObject context,
            final ErlFloat semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (macroName=MacroLiteral args=Expressions?)
     */
    protected void sequence_MacroCall(final EObject context,
            final MacroCall semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=[DefineAttribute|MACRO]
     */
    protected void sequence_MacroLiteral(final EObject context,
            final Macro semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=[DefineAttribute|NAMEVAR]
     */
    protected void sequence_MacroRef(final EObject context,
            final Macro semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (tag='module' moduleName=NAME)
     */
    protected void sequence_ModuleAttribute(final EObject context,
            final ModuleAttribute semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.ATTRIBUTE__TAG) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.ATTRIBUTE__TAG));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.MODULE_ATTRIBUTE__MODULE_NAME) == ValueTransient.YES) {
                errorAcceptor
                        .accept(diagnosticProvider
                                .createFeatureValueMissing(
                                        semanticObject,
                                        ErlangPackage.Literals.MODULE_ATTRIBUTE__MODULE_NAME));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getModuleAttributeAccess()
                .getTagModuleKeyword_0_0(), semanticObject.getTag());
        feeder.accept(grammarAccess.getModuleAttributeAccess()
                .getModuleNameNAMEParserRuleCall_2_0(), semanticObject
                .getModuleName());
        feeder.finish();
    }

    /**
     * Constraint: value=[Module|NAME]
     */
    protected void sequence_ModuleRef(final EObject context,
            final AtomRef semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: forms+=Form*
     */
    protected void sequence_Module(final EObject context,
            final Module semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((target=PatternExpression_FunCall_1_1_0 args=Expressions?) |
     * target=PatternExpression_FunCall_1_1_0)
     */
    protected void sequence_PatternExpression(final EObject context,
            final FunCall semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (opLeft=PatternExpression_MatchExpr_1_0_0 op='='
     * opRight=TermExpression)
     */
    protected void sequence_PatternExpression(final EObject context,
            final MatchExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: {QueryExpr}
     */
    protected void sequence_QueryExpr(final EObject context,
            final QueryExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((clauses+=CrClause clauses+=CrClause* (after_expr=Expression
     * after_body=Expressions)?) | (after_expr=Expression
     * after_body=Expressions))
     */
    protected void sequence_ReceiveExpr(final EObject context,
            final ReceiveExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (tag='record' name=NAMEMACRO ((fields+=RecordFieldDef
     * fields+=RecordFieldDef*)? | recordMacro=MacroCall))
     */
    protected void sequence_RecordAttribute(final EObject context,
            final RecordAttribute semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (rec=RecordVarMacro (field=RecordFieldVarMacro |
     * tuple=RecordTuple))
     */
    protected void sequence_RecordExpr(final EObject context,
            final RecordExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (name=NAMEVAR value=Expression? type=TopType?)
     */
    protected void sequence_RecordFieldDef(final EObject context,
            final RecordFieldDef semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (ref=RecordFieldVarMacro value=Expression? type=TopType?)
     */
    protected void sequence_RecordFieldExpr(final EObject context,
            final RecordFieldExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=[RecordFieldDef|NAME]
     */
    protected void sequence_RecordFieldRef(final EObject context,
            final AtomRef semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=[RecordAttribute|NAME]
     */
    protected void sequence_RecordRef(final EObject context,
            final AtomRef semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((fields+=RecordFieldExpr fields+=RecordFieldExpr*)?)
     */
    protected void sequence_RecordTuple(final EObject context,
            final RecordTuple semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ( (tag='spec' | tag='callback') ((ref=SpecFun
     * signatures+=TypeSig signatures+=TypeSig*) | (ref=SpecFun
     * signatures+=TypeSig signatures+=TypeSig*)) )
     */
    protected void sequence_SpecAttribute(final EObject context,
            final SpecAttribute semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (module=ModuleVarMacro? function=FunctionVarMacro
     * arity=IntVarMacro?)
     */
    protected void sequence_SpecFun(final EObject context,
            final FunRef semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: string=STRING
     */
    protected void sequence_StringLiteralLiteral(final EObject context,
            final StringLiteralPart semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (parts+=StringLiteralLiteral parts+=StringLiteralPart*)
     */
    protected void sequence_StringLiteral(final EObject context,
            final Expression semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (var=VARIABLE? type=Type100)
     */
    protected void sequence_TopType(final EObject context,
            final TopType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ( (leftOperand=Type400_TopType_1_0_0_0 op=MULTOP
     * rightOperand=Type500) | (var=VARIABLE? type=Type100) |
     * (leftOperand=Type300_TopType_1_0_0_0 op=ADDOP rightOperand=Type400) |
     * (leftOperand=Type200_TopType_1_0_0_0 op='..' rightOperand=Type300) |
     * (leftOperand=Type100_TopType_1_0_0_0 op='|' rightOperand=Type200) )
     */
    protected void sequence_TopType_Type100_Type200_Type300_Type400(
            final EObject context, final TopType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ( (leftOperand=Type400_TopType_1_0_0_0 op=MULTOP
     * rightOperand=Type500) | (var=VARIABLE? type=Type100) |
     * (leftOperand=Type300_TopType_1_0_0_0 op=ADDOP rightOperand=Type400) |
     * (leftOperand=Type200_TopType_1_0_0_0 op='..' rightOperand=Type300) )
     */
    protected void sequence_TopType_Type200_Type300_Type400(
            final EObject context, final TopType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ( (leftOperand=Type400_TopType_1_0_0_0 op=MULTOP
     * rightOperand=Type500) | (var=VARIABLE? type=Type100) |
     * (leftOperand=Type300_TopType_1_0_0_0 op=ADDOP rightOperand=Type400) )
     */
    protected void sequence_TopType_Type300_Type400(final EObject context,
            final TopType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((leftOperand=Type400_TopType_1_0_0_0 op=MULTOP
     * rightOperand=Type500) | (var=VARIABLE? type=Type100))
     */
    protected void sequence_TopType_Type400(final EObject context,
            final TopType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (hdr=NAMEVAR? cond=PatternExpression guard=Guard?
     * body=Expressions)
     */
    protected void sequence_TryClause(final EObject context,
            final TryClause semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ( body=Expressions (of_clauses+=CrClause
     * of_clauses+=CrClause*)? ((catch+=TryClause catch+=TryClause*
     * after_body=Expressions?) | after_body=Expressions) )
     */
    protected void sequence_TryExpr(final EObject context,
            final TryExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: {ErlTuple}
     */
    protected void sequence_Tuple(final EObject context,
            final ErlTuple semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (op=PREFIXOP operand=Type)
     */
    protected void sequence_Type500(final EObject context,
            final UnaryType semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.UNARY_TYPE__OP) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.UNARY_TYPE__OP));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.UNARY_TYPE__OPERAND) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.UNARY_TYPE__OPERAND));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getType500Access()
                .getOpPREFIXOPParserRuleCall_0_1_0(), semanticObject.getOp());
        feeder.accept(grammarAccess.getType500Access()
                .getOperandTypeParserRuleCall_0_2_0(), semanticObject
                .getOperand());
        feeder.finish();
    }

    /**
     * Constraint: ( (tag='type' | tag='opaque') ( (name=NAMEVAR
     * (args+=PatternExpression args+=PatternExpression*)? type=TopType) |
     * (name=NAMEVAR (args+=PatternExpression args+=PatternExpression*)?
     * type=TopType) ) )
     */
    protected void sequence_TypeAttribute(final EObject context,
            final TypeAttribute semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((typeName=TypeRef types+=TopType types+=TopType*) |
     * (typeName=VariableLiteral type=TopType))
     */
    protected void sequence_TypeGuard(final EObject context,
            final TypeGuard semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (items+=TypeGuard items+=TypeGuard*)
     */
    protected void sequence_TypeGuards(final EObject context,
            final TypeGuards semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=[TypeAttribute|NAME]
     */
    protected void sequence_TypeRef(final EObject context,
            final AtomRef semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (decl=FunType guards=TypeGuards?)
     */
    protected void sequence_TypeSig(final EObject context,
            final TypeSig semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (type=FunType100?)
     */
    protected void sequence_Type(final EObject context,
            final FunType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (type=TopType?)
     */
    protected void sequence_Type(final EObject context,
            final ListType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (rec=RecordRef (fields+=FieldType fields+=FieldType*)?)
     */
    protected void sequence_Type(final EObject context,
            final RecordType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (m=ModuleVarMacro? typeName=TypeRef (args+=TopType
     * args+=TopType*)?)
     */
    protected void sequence_Type(final EObject context,
            final RemoteType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((types+=TopType types+=TopType*)?)
     */
    protected void sequence_Type(final EObject context,
            final TupleType semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (typeName=VariableLiteral | value=INTEGER)
     */
    protected void sequence_Type(final EObject context,
            final Type semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (op=PREFIXOP operand=Expr700)
     */
    protected void sequence_UnaryExpr(final EObject context,
            final UnaryExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: ((op=PREFIXOP operand=ExprMax) | (op=PREFIXOP
     * operand=Expr700))
     */
    protected void sequence_UnaryExpr_UnaryExprMax(final EObject context,
            final UnaryExpr semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (tag='undef' ref=MacroRef)
     */
    protected void sequence_UndefAttribute(final EObject context,
            final UndefAttribute semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.ATTRIBUTE__TAG) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.ATTRIBUTE__TAG));
            }
            if (transientValues.isValueTransient(semanticObject,
                    ErlangPackage.Literals.UNDEF_ATTRIBUTE__REF) == ValueTransient.YES) {
                errorAcceptor.accept(diagnosticProvider
                        .createFeatureValueMissing(semanticObject,
                                ErlangPackage.Literals.UNDEF_ATTRIBUTE__REF));
            }
        }
        final INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        final SequenceFeeder feeder = createSequencerFeeder(semanticObject,
                nodes);
        feeder.accept(grammarAccess.getUndefAttributeAccess()
                .getTagUndefKeyword_0_0(), semanticObject.getTag());
        feeder.accept(grammarAccess.getUndefAttributeAccess()
                .getRefMacroRefParserRuleCall_2_0(), semanticObject.getRef());
        feeder.finish();
    }

    /**
     * Constraint: value=[Expression|VARIABLE]
     */
    protected void sequence_VariableLiteral(final EObject context,
            final Variable semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }
}
